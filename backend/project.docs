Let's focus on setting up the database structure for your backend using **Supabase**. Since we're dealing with **user authentication** and **other banking features**, we will need to create a proper database schema that includes tables for:

1. **Users** - to store authenticated users.
2. **Transactions** - for user banking operations.
3. **Loans** - for loan management.
4. **Roles** - for distinguishing between user and admin roles.

We'll also ensure that the structure aligns with best practices for **user authentication**, utilizing **Supabase Auth**.

### 1. Set Up the Database Schema

#### 1.1 **Users Table**

We will use Supabase's built-in authentication system, which automatically creates an `auth.users` table to store authenticated users, but we may want to extend this with extra fields like `profile_picture`, `account_balance`, etc.

#### 1.2 **Roles Table**

To manage roles (e.g., admin, user), we'll create a **roles table**.

#### 1.3 **Transactions Table**

The **transactions table** will store records of deposits, withdrawals, and transfers for each user.

#### 1.4 **Loans Table**

The **loans table** will store records for loan applications, including loan amounts, terms, statuses, and related users.

---

### 2. Supabase Database Setup

#### 2.1 **Create Tables in Supabase**

You can create these tables manually through the Supabase dashboard or using SQL migrations. Below is an SQL schema to create the necessary tables:

##### **Users Table (Extending Supabase Auth)**

We extend the built-in `auth.users` table with additional fields, but **do not** manually store password hashes because Supabase Auth handles it for us.

```sql
-- Create additional columns for user profiles
alter table auth.users
  add column phone_number varchar(15),
  add column profile_picture varchar(255),
  add column account_balance float default 0;

-- Optional: Create foreign key relationships or additional indices
```

##### **Roles Table**

We’ll define roles for both regular users and admins. This table will link users to their respective roles.

```sql
-- Create roles table
create table roles (
  id serial primary key,
  role_name varchar(50) not null unique,  -- e.g., 'user', 'admin'
  description text
);

-- Optional: Add default roles like 'user' and 'admin'
insert into roles (role_name, description) values
('user', 'Regular customer of the banking system'),
('admin', 'Administrator with elevated permissions');
```

##### **User-Roles Join Table**

Linking users to roles using a join table:

```sql
-- Create user_roles table to assign roles to users
create table user_roles (
  user_id uuid references auth.users(id) on delete cascade,
  role_id int references roles(id) on delete cascade,
  primary key (user_id, role_id)
);

-- Assign default role (user) to all users
insert into user_roles (user_id, role_id)
select id, (select id from roles where role_name = 'user') from auth.users;
```

##### **Transactions Table**

This table records all banking transactions.

```sql
-- Create transactions table
create table transactions (
  id serial primary key,
  user_id uuid references auth.users(id) on delete cascade,
  transaction_type varchar(50),  -- e.g., 'deposit', 'withdraw', 'transfer'
  amount float not null,
  transaction_date timestamp default current_timestamp,
  status varchar(20) default 'pending'  -- e.g., 'completed', 'failed'
);

-- Add an index for faster lookup by user
create index on transactions(user_id);
```

##### **Loans Table**

This table stores loan applications.

```sql
-- Create loans table
create table loans (
  id serial primary key,
  user_id uuid references auth.users(id) on delete cascade,
  loan_amount float not null,
  loan_term int,  -- Loan term in months
  interest_rate float,  -- Annual interest rate
  status varchar(20) default 'pending',  -- e.g., 'approved', 'rejected'
  application_date timestamp default current_timestamp,
  approved_date timestamp
);

-- Add an index for faster lookup by user
create index on loans(user_id);
```

#### 2.2 **Supabase Authentication**

Supabase automatically handles authentication for us using the `auth` schema, so users can sign up, log in, and manage sessions easily. You will interact with the `auth.users` table through Supabase's Auth API for user registration, login, etc.

Here’s an example of **signing up a user** using Supabase:

```javascript
import { createClient } from '@supabase/supabase-js';

const supabase = createClient('https://xyzcompany.supabase.co', 'your_public_anon_key');

// Register a new user
async function signUp(email, password, phoneNumber) {
  const { user, error } = await supabase.auth.signUp({
    email,
    password,
  });

  if (error) {
    console.log('Error signing up:', error.message);
  } else {
    // Optionally, insert additional data into the "users" table
    await supabase
      .from('users')
      .upsert({
        id: user.id,
        phone_number: phoneNumber,
        account_balance: 0,  // default balance for new users
      })
      .single();
    console.log('User signed up successfully:', user);
  }
}
```

---

### 3. Ensure Supabase Security Rules for Authentication

To follow best practices and ensure security, make sure to implement row-level security (RLS) in your Supabase tables. You’ll want to make sure that users can only access their own data.

#### 3.1 **Enable Row-Level Security (RLS)**

To enforce security on your tables, enable RLS for sensitive tables like `transactions`, `loans`, and any table that stores user-related data.

```sql
-- Enable row-level security on the transactions table
alter table transactions enable row level security;

-- Create a policy that allows users to only access their own transactions
create policy "select_transactions" on transactions
  for select
  using (user_id = auth.uid());

-- Enable row-level security on the loans table
alter table loans enable row level security;

-- Create a policy that allows users to only access their own loans
create policy "select_loans" on loans
  for select
  using (user_id = auth.uid());
```

You can create similar RLS policies for other tables.

---

### 4. Supabase API Authentication for Secure Endpoints

When users log in or make authenticated API calls, you will need to use **JWT tokens** provided by Supabase for user authentication. Here’s how you can implement secure API calls:

#### Example: Token-Based Authentication in Express.js

When the user logs in, they receive a JWT token from Supabase. You’ll need to send this token in requests to your backend to authenticate the user.

```javascript
const express = require('express');
const { createClient } = require('@supabase/supabase-js');

const app = express();
app.use(express.json());

const supabase = createClient('https://xyzcompany.supabase.co', 'your_public_anon_key');

// Middleware to check for valid JWT
async function verifyToken(req, res, next) {
  const token = req.headers['authorization'];

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  const { data: user, error } = await supabase.auth.api.getUser(token.replace('Bearer ', ''));

  if (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }

  req.user = user;
  next();
}

// Example protected route
app.post('/api/deposit', verifyToken, async (req, res) => {
  const { amount } = req.body;
  const { user } = req;

  // Perform transaction logic (e.g., update account balance)
  // You can now access the user's info via req.user
});

app.listen(5000, () => console.log('Server is running on port 5000'));
```

---

### Conclusion

We’ve outlined how to set up the necessary database schema for a **Banking System** with Supabase, including:

- Extending Supabase Auth for user management.
- Creating tables for transactions, loans, and roles.
- Enabling **Row-Level Security** to protect sensitive data.
- Using **JWT tokens** for secure user authentication in API calls.

This structure ensures a robust and scalable backend while keeping security and best practices in mind. Let me know if you need help with specific backend logic or database queries!




-- Altering the auth.users table to add additional columns
alter table auth.users
  add column phone_number varchar(15),          -- User's phone number
  add column profile_picture varchar(255),       -- URL or path to user's profile picture
  add column account_balance float default 0,    -- Default balance for the user (0 initially)
  add column created_at timestamp default current_timestamp,  -- Automatically capture account creation time
  add column updated_at timestamp default current_timestamp;  -- Automatically capture last update time

-- Create an index on phone_number for faster lookups (optional but recommended)
create index if not exists idx_phone_number on auth.users(phone_number);

-- Optional: If you plan to link users to specific roles or other entities, 
-- you can add foreign key constraints here. However, we already have the user_roles 
-- table to handle user roles, so this may not be necessary for now.

-- Ensure that 'updated_at' is updated automatically whenever a user record is updated
create or replace function update_user_timestamp() 
  returns trigger as $$
begin
  new.updated_at = current_timestamp;
  return new;
end;
$$ language plpgsql;

create trigger trigger_update_user_timestamp
  before update on auth.users
  for each row execute function update_user_timestamp();



-- SQL Function to update account balance
create or replace function update_balance(account_id uuid, transaction_type varchar, amount decimal)
returns void language plpgsql as $$
begin
  if transaction_type = 'deposit' then
    update accounts
    set balance = balance + amount
    where id = account_id;
  elsif transaction_type = 'withdrawal' then
    update accounts
    set balance = balance - amount
    where id = account_id;
  else
    raise exception 'Invalid transaction type';
  end if;
end;
$$;
